Testing:
——————————————————————————————————————————
Don’t just test the ideal, expected path that everyone would follow in a perfect world. Try to break the solution, and test edge cases.
——————————————————————————————————————————
Types of testing:

1. Unit Testing: tests small pieces of code to ensure that the individual parts of a program work properly on their own

2. Integration Testing: verifies that different modules or services used by your application work well together 
	(ie: tests the interface between the different modules)
	ex: testing the interaction between the database and microservices work together

3. Functional Testing: focuses on the business requirements of an application. They only verify the output of an action and do not check the intermediate states of the system when performing that action.

4. End to End Testing: replicates user behavior with the software in a complete application. It verifies that various user flows 

5. User Aceptance Testing: end users accept/reject the final feature delivery

6. Performance Testing: evaluates the speed, stability, reliability, scalability, and resource usage and how a system performs under a particular workload.

7. Stress Testing: tests beyond normal operational capacity to test the results. 

8. Smoke Testing: basic tests that check the basic functionality of an application. They are meant to be quick to execute, and their goal is to give you the assurance that the major features of your system are working as expected.
	
	Smoke tests can be useful right after a new build is made to decide whether or not you can run more expensive tests, or right after a deployment to make sure that they application is running properly in the newly deployed environment.

9. Sanity Testing: The objective is not to verify thoroughly the new functionality but to determine that the developer has applied some rationality while producing the software. 
	EX: if your calculator gives the result of 2 + 2 =5, theres no point testing the advanced functionalities like sin 30 + cos 50.

10. Regression Testing: tests whether new code broke the already working application

11. Security Testing: unveils the vulnerabilities of the system to ensure that the system are free from any threats or risks. These tests aim to find any potential flaws and weaknesses in the software system that could lead to a loss of data, revenue, or reputation per employees or outsides of a company. 

12. Accessibility Testing: ensures your system works is usable for users with/without disabilities 
	EX: vision impairment, hearing disabilities, and other physical or cognitive conditions. 
——————————————————————————————————————————